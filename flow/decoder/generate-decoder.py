#!/usr/bin/env python3

from __future__ import print_function
from builtins import hex
from builtins import range
import math
import sys
import tokenize

namelist = []
match = {}
mask = {}
pseudos = {}
arguments = {}

arglut = {}
arglut['rd'] = (11,7)
arglut['rs1'] = (19,15)
arglut['rt'] = (19,15)
arglut['rs2'] = (24,20)
arglut['rcon'] = (23,20)
arglut['rs3'] = (31,27)
arglut['aqrl'] = (26,25)
arglut['fm'] = (31,28)
arglut['bs'] = (31,30)
arglut['pred'] = (27,24)
arglut['succ'] = (23,20)
arglut['rm'] = (14,12)
arglut['funct3'] = (14,12)
arglut['imm20'] = (31,12)
arglut['jimm20'] = (31,12)
arglut['imm12'] = (31,20)
arglut['imm12hi'] = (31,25)
arglut['bimm12hi'] = (31,25)
arglut['imm12lo'] = (11,7)
arglut['bimm12lo'] = (11,7)
arglut['zimm'] = (19,15)
arglut['shamt'] = (25,20)
arglut['shamtw'] = (24,20)


opcode_base = 0
opcode_size = 7
funct_base = 12
funct_size = 3

def binary(n, digits=0):
  rep = bin(n)[2:]
  return rep if digits == 0 else ('0' * (digits - len(rep))) + rep

def yank(num,start,len):
  return (num >> start) & ((1 << len) - 1)

def str_arg(arg0,name,match,arguments):
  if arg0 in arguments:
    return name or arg0
  else:
    start = arglut[arg0][1]
    len = arglut[arg0][0] - arglut[arg0][1] + 1
    return binary(yank(match,start,len),len)

def str_inst(name,arguments):
  return name.replace('.rv32','').upper()

def print_verilog_insn(name):
  s = "wire dec_%-18s = " % name.replace('.', '_').lower()

  match_bits = match[name]
  mask_bits  = mask [name]

  match_bits = hex(match_bits)[2:]
  mask_bits  = hex(mask_bits )[2:]

  s += "(s1_instr & 32'h%s) == 32'h%s" % (mask_bits,match_bits)

  print(s + ";")

def make_verilog():
  print('/* Automatically generated by parse_opcodes */')
  for name in namelist:
    print_verilog_insn(name)

  for kn in arglut.keys():
    hi,lo = arglut[kn]
    print("wire [%2d:%d] dec_%-18s = s1_instr[%2d:%2d];" % (
      hi-lo,0,kn,hi,lo
    ))

def parse_inputs(args):
  inputs = []
  for fn in args:
      try:
          inputs.append(open(fn))
      except:
          assert(0)
  if not inputs:
      inputs.append(sys.stdin)

  for f in inputs:
    for line in f:
      line = line.partition('#')
      tokens = line[0].split()

      if len(tokens) == 0:
        continue
      assert len(tokens) >= 2

      name = tokens[0]
      pseudo = name[0] == '@'
      if pseudo:
        name = name[1:]
      mymatch = 0
      mymask = 0
      cover = 0

      if not name in list(arguments.keys()):
        arguments[name] = []

      for token in tokens[1:]:
        if len(token.split('=')) == 2:
          tokens = token.split('=')
          if len(tokens[0].split('..')) == 2:
            tmp = tokens[0].split('..')
            hi = int(tmp[0])
            lo = int(tmp[1])
            if hi <= lo:
              sys.exit("%s: bad range %d..%d" % (name,hi,lo))
          else:
            hi = lo = int(tokens[0])

          if tokens[1] != 'ignore':
            val = int(tokens[1], 0)
            if val >= (1 << (hi-lo+1)):
              sys.exit("%s: bad value %d for range %d..%d" % (name,val,hi,lo))
            mymatch = mymatch | (val << lo)
            mymask = mymask | ((1<<(hi+1))-(1<<lo))

          if cover & ((1<<(hi+1))-(1<<lo)):
            sys.exit("%s: overspecified" % name)
          cover = cover | ((1<<(hi+1))-(1<<lo))

        elif token in arglut:
          if cover & ((1<<(arglut[token][0]+1))-(1<<arglut[token][1])):
            sys.exit("%s: overspecified" % name)
          cover = cover | ((1<<(arglut[token][0]+1))-(1<<arglut[token][1]))
          arguments[name].append(token)

        else:
          sys.exit("%s: unknown token %s" % (name,token))

      if not (cover == 0xFFFFFFFF or cover == 0xFFFF):
        sys.exit("%s: not all bits are covered" % name)

      if pseudo:
        pseudos[name] = 1
      else:
        for name2,match2 in match.items():
          if name2 not in pseudos and (match2 & mymask) == mymatch:
            sys.exit("%s and %s overlap" % (name,name2))

      mask[name] = mymask
      match[name] = mymatch
      namelist.append(name)

    if f is not sys.stdin:
        f.close()
  return (namelist, pseudos, mask, match, arguments)

if __name__ == "__main__":
  parse_inputs(sys.argv[2:])
  if sys.argv[1] == '-verilog':
    make_verilog()
  else:
    assert 0

